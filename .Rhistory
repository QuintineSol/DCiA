ergm <- ergm::ergm(N_colab_net ~ edges + gwnsp(decay = 0.1, fixed = T),
control = ergm::control.ergm(MCMC.burnin = 500,
MCMC.samplesize = 1000,
seed = 123456,
MCMLE.maxit = 2,
parallel = 6,
parallel.type = "PSOCK"))
(sum_ergm <- summary(ergm))
ergm::mcmc.diagnostics(ergm)
ergm <- ergm::ergm(N_colab_net ~ edges + gwesp(decay = 0.1, fixed = T),
control = ergm::control.ergm(MCMC.burnin = 500,
MCMC.samplesize = 1000,
seed = 123456,
MCMLE.maxit = 2,
parallel = 6,
parallel.type = "PSOCK"))
plot(N_colab_net,
vertex.size = 5,
edge.size = igraph::E(net)$weight/32,
edge.arrow.size = 0.2,
vertex.color = ifelse(igraph::V(biproj)$affiliation== 'Tilburg University',
"navy", "red"),
vertex.label.cex = 0.4,
vertex.label.color = 'black',
vertex.frame.color = "#ffffff",
vertex.label = NA,
layout = igraph::layout.fruchterman.reingold,
main= paste('Tilburg papers associated with Decision Sciences'))
plot(snafun::to_igraph(N_colab_net),
vertex.size = 5,
edge.size = igraph::E(net)$weight/32,
edge.arrow.size = 0.2,
vertex.color = ifelse(igraph::V(biproj)$affiliation== 'Tilburg University',
"navy", "red"),
vertex.label.cex = 0.4,
vertex.label.color = 'black',
vertex.frame.color = "#ffffff",
vertex.label = NA,
layout = igraph::layout.fruchterman.reingold,
main= paste('Tilburg papers associated with Decision Sciences'))
plot(snafun::to_igraph(N_colab_net),
vertex.size = 5,
edge.size = igraph::E(net)$weight/32,
edge.arrow.size = 0.2,
vertex.color = ifelse(igraph::V(snafun::to_igraph(N_colab_net))$affiliation== 'Tilburg University',
"navy", "red"),
vertex.label.cex = 0.4,
vertex.label.color = 'black',
vertex.frame.color = "#ffffff",
vertex.label = NA,
layout = igraph::layout.fruchterman.reingold,
main= paste('Tilburg papers associated with Decision Sciences'))
ergm <- ergm::ergm(N_colab_net ~ edges + altkstar(0.2, fixed = T)+ nodematch('affiliation', diff = T),
control = ergm::control.ergm(MCMC.burnin = 500,
MCMC.samplesize = 1000,
seed = 123456,
MCMLE.maxit = 2,
parallel = 6,
parallel.type = "PSOCK"))
ergm <- ergm::ergm(N_colab_net ~ edges + altkstar(0.2, fixed = T)+ nodematch('affiliation', diff = T),
control = ergm::control.ergm(MCMC.burnin = 2000,
MCMC.samplesize = 5000,
seed = 123456,
MCMLE.maxit = 10,
parallel = 6,
parallel.type = "PSOCK"))
ergm <- ergm::ergm(N_colab_net ~ edges + altkstar(0.2, fixed = T)+ nodematch('affiliation', diff = T),
control = ergm::control.ergm(MCMC.burnin = 100,
MCMC.samplesize = 500,
seed = 123456,
MCMLE.maxit = 10,
parallel = 6,
parallel.type = "PSOCK"))
ergm <- ergm::ergm(N_colab_net ~ edges + altkstar(0.2, fixed = T)+ nodematch('affiliation'),
control = ergm::control.ergm(MCMC.burnin = 100,
MCMC.samplesize = 500,
seed = 123456,
MCMLE.maxit = 10,
parallel = 6,
parallel.type = "PSOCK"))
ergm <- ergm::ergm(N_colab_net ~ edges + altkstar(0.2, fixed = T)+ nodematch('in_tilburg'),
control = ergm::control.ergm(MCMC.burnin = 100,
MCMC.samplesize = 500,
seed = 123456,
MCMLE.maxit = 10,
parallel = 6,
parallel.type = "PSOCK"))
ergm <- ergm::ergm(N_colab_net ~ edges + altkstar(0.2, fixed = T)+ gwdsp(0.2, fixed = T) nodecov('nb_citations') + abs_diff('nb_citations') + absdiff('time_since_degree') + nodematch("affiliation") + nodecov("paper_count"),
ergm <- ergm::ergm(N_colab_net ~ edges + altkstar(0.2, fixed = T)+ gwdsp(0.2, fixed = T) + nodecov('nb_citations') + abs_diff('nb_citations') + absdiff('time_since_degree') + nodematch("affiliation") + nodecov("paper_count"),
control = ergm::control.ergm(MCMC.burnin = 10000,
MCMC.samplesize = 30000,
seed = 123456,
MCMLE.maxit = 5,
parallel = 6,
parallel.type = "PSOCK"))
ergm <- ergm::ergm(N_colab_net ~ edges + altkstar(0.2, fixed = T)+ gwdsp(0.2, fixed = T) + nodecov('nb_citations') + absdiff('nb_citations') + absdiff('time_since_degree') + nodematch("affiliation") + nodecov("paper_count"),
control = ergm::control.ergm(MCMC.burnin = 10000,
MCMC.samplesize = 30000,
seed = 123456,
MCMLE.maxit = 5,
parallel = 6,
parallel.type = "PSOCK"))
ergm <- ergm::ergm(N_colab_net ~ edges + altkstar(0.6, fixed = T) + nodecov('nb_citations') + absdiff('nb_citations') + absdiff('time_since_degree') + nodematch("affiliation"),
control = ergm::control.ergm(MCMC.burnin = 10000,
MCMC.samplesize = 30000,
seed = 123456,
MCMLE.maxit = 5,
parallel = 6,
parallel.type = "PSOCK"))
(sum_ergm <- summary(ergm))
ergm <- ergm::ergm(N_colab_net ~ edges + gwdsp(0.6, fixed = T) + nodecov('nb_citations') + absdiff('nb_citations') + absdiff('time_since_degree') + nodematch("affiliation"),
control = ergm::control.ergm(MCMC.burnin = 10000,
MCMC.samplesize = 30000,
seed = 123456,
MCMLE.maxit = 5,
parallel = 6,
parallel.type = "PSOCK"))
(sum_ergm <- summary(ergm))
ergm::mcmc.diagnostics(ergm)
ergm <- ergm::ergm(N_colab_net ~ edges + gwdsp(0.6, fixed = T) + nodecov('nb_citations') + absdiff('nb_citations') + absdiff('time_since_degree') + nodematch("affiliation"),
control = ergm::control.ergm(MCMC.burnin = 10000,
MCMC.samplesize = 30000,
seed = 123456,
MCMLE.maxit = 10,
parallel = 6,
parallel.type = "PSOCK"))
ergm
ergm <- ergm::ergm(N_colab_net ~ edges + altkstar(0.6, fixed = T) + nodecov('nb_citations') + absdiff('nb_citations') + absdiff('time_since_degree') + nodematch("affiliation"),
control = ergm::control.ergm(MCMC.burnin = 10000,
MCMC.samplesize = 30000,
seed = 123456,
MCMLE.maxit = 10,
parallel = 6,
parallel.type = "PSOCK"))
(sum_ergm <- summary(ergm))
ergm::mcmc.diagnostics(ergm)
ergm::gof(ergm)
ergm <- ergm::ergm(N_colab_net ~ edges + altkstar(0.6, fixed = T) + gwdegree(0,6) + nodecov('nb_citations') + absdiff('nb_citations') + absdiff('time_since_degree') + nodematch("affiliation"),
control = ergm::control.ergm(MCMC.burnin = 10000,
MCMC.samplesize = 30000,
seed = 123456,
MCMLE.maxit = 10,
parallel = 6,
parallel.type = "PSOCK"))
ergm <- ergm::ergm(N_colab_net ~ edges + altkstar(0.6, fixed = T) + gwdegree(0.6, fixed=T) + nodecov('nb_citations') + absdiff('nb_citations') + absdiff('time_since_degree') + nodematch("affiliation"),
control = ergm::control.ergm(MCMC.burnin = 10000,
MCMC.samplesize = 30000,
seed = 123456,
MCMLE.maxit = 10,
parallel = 6,
parallel.type = "PSOCK"))
(sum_ergm <- summary(ergm))
ergm::gof(ergm)
if(!requireNamespace("tinytex", quietly = TRUE)) install.packages("tinytex")
tinytex::install_tinytex()
# Install latest CRAN release
install.packages("papaja")
# Install remotes package if necessary
if(!requireNamespace("remotes", quietly = TRUE)) install.packages("remotes")
# Install the stable development version from GitHub
remotes::install_github("crsh/papaja")
unlink("C:/Users/20202016/Downloads/Final Report_cache", recursive = TRUE)
library("papaja")
r_refs("r-references.bib")
# Seed for random number generation
set.seed(42)
knitr::opts_chunk$set(cache.extra = knitr::rand_seed)
# table example
cn <- c("age", "gender", "eyes_col")
one <- c(7, "M", "BLUE")
two <- c(8, "F", "BROWN")
three <- c(8, "M", "GREEN")
four <- c(7, "F", "PINK")
tab <- rbind(cn, one, two, three, four)
rownames(tab) <- NULL
knitr::kable(tab)
# model results display example
ctl <- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
trt <- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
group <- gl(2, 10, 20, labels = c("Ctl","Trt"))
weight <- c(ctl, trt)
lm.D9 <- lm(weight ~ group)
lm.D90 <- lm(weight ~ group - 1)
# install.packages("texreg")
knitr::kable(texreg::matrixreg(lm.D9))
# model results display example
ctl <- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
trt <- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
group <- gl(2, 10, 20, labels = c("Ctl","Trt"))
weight <- c(ctl, trt)
lm.D9 <- lm(weight ~ group)
lm.D90 <- lm(weight ~ group - 1)
# install.packages("texreg")
knitr::kable(texreg::matrixreg(list(lm.D9, lm.D90)))
# model results display example
ctl <- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
trt <- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
group <- gl(2, 10, 20, labels = c("Ctl","Trt"))
weight <- c(ctl, trt)
lm.D9 <- lm(weight ~ group)
lm.D90 <- lm(weight ~ group - 1)
# install.packages("texreg")
texreg::plotreg(lm.D9)
# model results display example
ctl <- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
trt <- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
group <- gl(2, 10, 20, labels = c("Ctl","Trt"))
weight <- c(ctl, trt)
lm.D9 <- lm(weight ~ group)
lm.D90 <- lm(weight ~ group - 1)
# install.packages("texreg")
texreg::plotreg(list(lm.D9, lm.D90))
sna4tutti::open_sna4tutti_tutorials()
sna4tutti::open_sna4tutti_tutorials()
sna4tutti::open_sna4tutti_tutorials()
sna4tutti::open_sna4tutti_tutorials()
sna4tutti::open_sna4tutti_tutorials()
?snafun:::make_matrix_from_vertex_attribute
sna4tutti::open_sna4tutti_tutorials()
gc()
rm(list = ls())
data("florentine", package = "SNA4DSData")
flobusiness <- florentine$flobusiness
flomarriage <- florentine$flomarriage
floattrs <- florentine$floattrs
snafun::print(flobusiness)
snafun::g_summary(flobusiness)
snafun::print(flomarriage)
snafun::g_summary(flomarriage)
snafun::plot(flomarriage)
flomarriage |>
snafun::v_degree() |>
hist(main = "degree distribution of flomarriage")
# QAP test
snafun::g_correlation(flobus_network, flomar_network)
# QAP test
snafun::g_correlation(flobusiness, flomarriage)
floCor <- sna::qaptest(list(flobus_network, flomar_network),
FUN = snafun::g_correlation, reps = 1000)
floCor <- sna::qaptest(list(flobusiness, flomarriage),
FUN = snafun::g_correlation, reps = 1000)
flobusiness <- snafun::to_matrix(flobusiness)
flomarriage <- snafun::to_matrix(flomarriage)
floCor <- sna::qaptest(list(flobusiness, flomarriage),
FUN = snafun::g_correlation, reps = 1000)
floCor
sna::plot.qaptest(floCor)
# QAP linear
data(Sampson, package = "SNA4DSData")
mod <- sna::netlm(y = Sampson_like3, x = list(Sampson_like1, Sampson_like2,
t(Sampson_like3), Sampson_desesteem),
nullhyp = 'qapspp', reps = 1001)
Sampson_like3 <- Sampson$Sampson_like3
mod <- sna::netlm(y = Sampson_like3, x = list(Sampson_like1, Sampson_like2,
t(Sampson_like3), Sampson_desesteem),
nullhyp = 'qapspp', reps = 1001)
Sampson_like3 <- snafun::to_matrix(Sampson$Sampson_like3)
mod <- sna::netlm(y = Sampson_like3, x = list(Sampson_like1, Sampson_like2,
t(Sampson_like3), Sampson_desesteem),
nullhyp = 'qapspp', reps = 1001)
Sampson_like1 <- snafun::to_matrix(Sampson$Sampson_like1)
Sampson_like2 <- snafun::to_matrix(Sampson$Sampson_like2)
Sampson_like3 <- snafun::to_matrix(Sampson$Sampson_like3)
Sampson_desesteem <- snafun::to_matrix(Sampson$Sampson_desesteem)
mod <- sna::netlm(y = Sampson_like3, x = list(Sampson_like1, Sampson_like2,
t(Sampson_like3), Sampson_desesteem),
nullhyp = 'qapspp', reps = 1001)
mod$names <- c("Intcpt", "Liking 1", "Liking 2", "Being liked", "Desesteem")
summary(mod)
# QAP logistic
snafun::extract_vertex_attribute(flobus_network, "Wealth")
# QAP logistic
snafun::extract_vertex_attribute(flobusiness, "Wealth")
# QAP logistic
flobus_network <- snafun::to_network(flobusiness)
snafun::extract_vertex_attribute(flobus_network, "Wealth")
flobus_network
flobusiness
flobusiness <- florentine$flobusiness
flomarriage <- florentine$flomarriage
floattrs <- florentine$floattrs
flobusiness
# QAP logistic
flobus_network <- snafun::to_network(flobusiness)
snafun::extract_vertex_attribute(flobus_network, "Wealth")
wealth_absdiff <- snafun::make_matrix_from_vertex_attribute(flobus_network,
name = "Wealth", measure = "absdiff")
wealth_absdiff
flomar_network <- snafun::to_network(flomarriage)
w_absdiff <- sna::netlogit(flobus_network,
list(flomar_network, wealth_absdiff),
nullhyp = "qapspp", reps = 1001)
w_absdiff$names <- c("Intcpt", "Marriage", "Wealth difference")
summary(w_absdiff)
data("louis", package="SNA4DSData")
snafun::print(louis)
snafun::v_stress(louis, directed=T)
snafun::v_stress(louis, directed=F)
data("blogosphere", package="SNA4DSData")
snafun::print(blogosphere)
data(UKfaculty, package="igraphdata")
UKfaculty
# QAP
data("florentine", package = "SNA4DSData")
florentine
flobusiness <- florentine$flobusiness
snafun::v_stress(flobusiness)
snafun::v_betweenness(flobusiness, directed=F)
snafun::v_stress(flobusiness)
snafun::v_stress(flobusiness, directed = F)
data(UKfaculty, package="igraphdata")
igraph::tkplot(UKfaculty)
search.ergmTerms()
ergm::search.ergmTerms()
ergm::search.ergmTerms(keywords = "undirected")
ergm
Hookups <- ina::Hookups
class(Hookups)
ergm::ergm.searchTerms(keyword="edgecov")
ergm::search.ergmTerms(keywords = "edgecov")
ergm::search.ergmTerms("edgecov")
ergm::ergm(Hookups ~ edges + edgecov(snafun::d_structural_equivalence(Hookups)))
ergm <- ergm::ergm(Hookups ~ edges + edgecov(snafun::d_structural_equivalence(Hookups)))
summary(ergm)
erg:: search.ergmTerms(search='depede
erg:: search.ergmTerms(search='depede
erg:: search.ergmTerms(search='dependent')
ergm:: search.ergmTerms(search='dependent')
# QAP
data("florentine", package = "SNA4DSData")
ergm::mcmc.diagnostics(ergm)
ergm <- ergm::ergm(Hookups ~ edges + edgecov(snafun::d_structural_equivalence(Hookups)),
MCMC.burnin = 500,
MCMC.samplesize = 1500,
seed = 123456,
MCMLE.maxit = 2,
parallel = 6,
parallel.type = "PSOCK"))
ergm <- ergm::ergm(Hookups ~ edges + edgecov(snafun::d_structural_equivalence(Hookups)),
MCMC.burnin = 500,
MCMC.samplesize = 1500,
seed = 123456,
MCMLE.maxit = 2,
parallel = 6,
parallel.type = "PSOCK")
ergm <- ergm::ergm(Hookups ~ edges + edgecov(snafun::d_structural_equivalence(Hookups)),
control = ergm::control.ergm(MCMC.burnin = 500,
MCMC.samplesize = 1500,
seed = 123456,
MCMLE.maxit = 2,
parallel = 6,
parallel.type = "PSOCK"))
summary(ergm)
ergm::mcmc.diagnostics(ergm)
ergm <- ergm::ergm(Hookups ~ edges + edgecov(snafun::d_structural_equivalence(Hookups)),
control = ergm::control.ergm(MCMC.burnin = 500,
MCMC.samplesize = 1500,
seed = 123456,
MCMLE.maxit = 5,
parallel = 6,
parallel.type = "PSOCK"))
summary(ergm)
ergm::mcmc.diagnostics(ergm)
erg:: search.ergmTerms(search='dependent')
ergm:: search.ergmTerms(search='dependent')
ergm:: search.ergmTerms(search='independent')
setwd("~/Master/Semester 2/Data Consultancy in Action/DCiA")
load_network = function(network, output = 'network', vlist = NULL, directed = F){
#' The load network function takes a network-like object and returns an attribute with a network object
#'
#' The network input can be defined in mutiple different ways:
#' - An igraph object
#' - A network object
#' - An edge list (Defined as a matrix with size x, 2) and optional vertex list
#' - An incidence matrix (if its a matrix with size n, m)
#' - An adjacency matrix (if its a matrix with size n, n)
#'
#' There multiple different parameters which can be defined:
#' output: Defines which output is generated. Can be either 'network' (default) or 'igraph'
#' vlist (optional): List of all vertices to provide when providing an edge list
#' directed (optional): Whether the network is directed or not (default is undirected)
if (snafun::is_igraph(network)){
# igraph
if (output == 'network'){
return(snafun::to_network(network))
} else if (output == 'igraph'){
return(network)
}
}else if (snafun::is_network(network)){
#network
if (output == 'network'){
return(network)
} else if (output == 'igraph'){
return(snafun::to_igraph(network))
}
}else if (class(network)[1]=='matrix'){
if (dim(network)[1] == dim(network)[2]){
if (all(t(network) == network)){
# Undirected Adjacency matrix
if (output == 'network'){
return(snafun::to_network(igraph::graph_from_adjacency_matrix(network, mode = 'undirected', diag = FALSE)))
} else if (output == 'igraph'){
return(igraph::graph_from_adjacency_matrix(network, mode = 'undirected', diag = FALSE))
}
} else {
# Directed Adjacency matrix (nxn)
if (output == 'network'){
return(snafun::to_network(igraph::graph_from_adjacency_matrix(network, mode = 'directed', diag = FALSE)))
} else if (output == 'igraph'){
return(igraph::graph_from_adjacency_matrix(network, mode = 'directed', diag = FALSE))
}
}
} else if (dim(network)[2] == 2){
# edge list
bipartite = length(intersect(network[,1], network[,2])) == 0
if (bipartite){
net = igraph::graph_from_data_frame(network, directed = directed)
igraph::V(net)$type = ifelse(igraph::V(net)$name %in% network[,1],
yes = FALSE, no = TRUE
) # Create bipartite division between the nodes
if (output == 'network'){
return(snafun::to_network(snafun::to_matrix(net), bipartite = T))
} else if (output == 'igraph'){
return(net)
}
} else {
if (output == 'network'){
return(snafun::to_network(igraph::graph_from_data_frame(network, directed = directed, vertices = vlist)))
} else if (output == 'igraph'){
return(igraph::graph_from_data_frame(network, directed = directed, vertices = vlist))
}
}
} else{
# Incidence matrix (mxn)
if (output == 'network'){
return(snafun::to_network(igraph::graph_from_incidence_matrix(network, directed = directed, mode = 'out'), bipartite = T))
} else if (output == 'igraph'){
return(igraph::graph_from_incidence_matrix(network, directed = directed, mode = 'out'))
}
}
}
}
apollo_network_from_excel = function(directory = NULL, sheet = c('attributes', 'knowledge', 'co-author', 'grants_people', 'grants'), type = 'igraph'){
#' A function to easily load the Apollo dataset into an igraph or network object (test)
#'
#' There multiple different parameters which can be defined:
#' directory (optional): directory of the excel files. If empty, file will be searched for in the data folder within the directory of this file
#' sheet: sheet type which must be imported. Has to be one of the following:
#' - attributes: Collects the attributes of all the nodes based on Attribute table_Final.xlsx and returns them in 3 separate tables including added explanation
#' - knowledge: Returns the knowledge network
#' - co-author: Returns the co-authorship network
#' - grants_people: Returns the unipartite projection of the grant network
#' - grants: Returns the bipartite grant network
#' type: Defines which output is generated. Can be either 'network' or 'igraph' (default)
suppressWarnings({
match.arg(sheet)
file_names = c('attributes' = 'Attribute table_Final.xlsx',
'knowledge' = 'knowledge_sharing_people_to_people.csv',
'co-author' = 'co_authorship_people_to_people.csv',
'grants_people' = 'grants_people_to_people.csv',
'grants' = 'grants_people_to_grant application.csv')
if (sheet != 'attributes'){
if (!is.null(directory)){
return(load_network(as.matrix(read.csv(paste0(directory,'/', file_names[sheet]), sheet = sheet_number)), output = type))
} else{
return(load_network(as.matrix(read.csv(paste0(dirname(rstudioapi::getSourceEditorContext()$path), '/Data/', file_names[sheet]))), output = type))
}
} else{
if (is.null(directory)){
temp = as.data.frame(readxl::read_xlsx(paste0(dirname(rstudioapi::getSourceEditorContext()$path),
'/Data/', file_names[sheet]), col_types = 'text'))
temp2 = as.data.frame(readxl::read_xlsx(paste0(dirname(rstudioapi::getSourceEditorContext()$path),
'/Data/', file_names[sheet]), col_types = 'text', sheet = 2, col_names = F))
} else{
temp = as.data.frame(readxl::read_xlsx(paste0(directory,
'/', file_names[sheet]), col_types = 'text'))
temp2 = as.data.frame(readxl::read_xlsx(paste0(directory,
'/', file_names[sheet]), col_types = 'text', sheet = 2, col_names = F))
}
person_start = rownames(temp[which(as.integer(temp$Node)>999999)[1],])
doi_start = rownames(temp[which(is.na(as.integer(temp$Node)))[1],])
paper_table = temp[doi_start:nrow(temp),]
people_table = temp[person_start:doi_start,]
grant_table = temp[1:person_start,]
faculty_dct = setNames(temp2[2:5, '...1'], temp2[2:5, '...2'])
PI_dct = setNames(temp2[c(9,10), '...1'], temp2[c(9,10), '...2'])
staff_dct = setNames(temp2[c(2,3), '...5'], temp2[c(2,3), '...6'])
grant_dct = setNames(temp2[c(9,10), '...5'], temp2[c(9,10), '...6'])
explenations = temp2[which(!is.na(temp2$...9)), c('...8', '...9')]
colnames(explenations) = c('Term', 'Definition')
grant_table = grant_table[, c('Node', 'Grant Application Academic Year', 'Grant Awarded')]
grant_table$`Grant Awarded` = grant_dct[grant_table$`Grant Awarded`]
grant_table$Node = as.integer(grant_table$Node)
grant_table$`Grant Awarded` = as.factor(grant_table$`Grant Awarded`)
people_table = people_table[, !names(people_table) %in% c('Grant Application Academic Year', 'Grant Awarded', 'DOI Year')]
people_table$`PI/Not a PI` = PI_dct[people_table$`PI/Not a PI`]
people_table$Faculty = faculty_dct[people_table$Faculty]
people_table$Faculty[is.na(people_table$Faculty)] = 'External Faculty'
people_table$`Internal Staff vs. External Staff` = staff_dct[people_table$`Internal Staff vs. External Staff`]
people_table$Node = as.integer(people_table$Node)
people_table$Faculty = as.factor(people_table$Faculty)
people_table$`PI/Not a PI` = as.factor(people_table$`PI/Not a PI`)
people_table$`Internal Staff vs. External Staff` = as.factor(people_table$`Internal Staff vs. External Staff`)
paper_table = paper_table[,c('Node', 'DOI Year')]
paper_table$`DOI Year` = as.integer(paper_table$`DOI Year`)
return(list('paper_table' = paper_table, 'people_table' = people_table, 'grant_table' = grant_table, 'explanations' = explenations))
}
})
}
apollo_network_from_excel(sheet= 'co-author', type = 'network')
coauthor_net <- apollo_network_from_excel(sheet= 'co-author', type = 'network')
snafun::plot(coauthor_net)
